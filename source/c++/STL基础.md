# 1 STL容器
## 1.1 vector
* 底层是连续内存数组
* 迭代器：start、finish、end_of_storage
* 扩容机制：空间不够，原空间大小乘2与新空间大小的最大值，容量扩张：重新配置、元素移动、释放原空间
## list
* 底层是循环双向链表
* pre、next、data
## deque
* 双向队列
* 维护一个map指针
* 迭代器：start、finish
* 前端、后端都可以扩容
## stack和queue
* 底层是deque
* stack封住了头端的开口
* queue封住了尾端的开口
## priority_queue
* 底层是vector
* 以heap为处理规则，heap的本质是一个完全二叉树
## set和map
* 底层是红黑树，红黑树是一种二叉搜索树，多一个颜色属性，是一种弱平衡二叉树（相对平衡二叉树、旋转次数少）
* 红黑树
  * 节点非黑即红
  * 根节点为黑
  * 一个结点是红的，它的子结点是黑的
  * 任一结点到尾端的路径上黑色结点个数相同
  * 插入最多两次旋转，删除最多三次旋转
# 2 增、删、查的复杂度
* vector：数组
  * 访问：时间复杂度O(1)
  * 查找：时间复杂度O(n) 
  * 插入、删除：尾部最快，头部最慢
* list：链表
  * 访问：时间复杂度O(n)
  * 插入、删除：移动过指针
* deque：双端数组
  * 访问：速度低于vector
  * 插入、删除：尾部、头部都快
* set和map：红黑树基于链表
  * 增删改查：时间复杂度O(log n)
  * 占用内存较小
* unordered_map和unordered_set:基于哈希表，无序
  * 增删改查：时间复杂度O(1),最差（O(n)）
  * 数据分布影响容器的性能
# 3 STL内存管理
* 提升内存管理效率，减小申请小内存造成内存碎片问题：采用两级配置器
  * 分配的空间大小超过128B时，使用一级空间配置器，直接使用malloc()、realloc()、free()函数进行内存空间的配置和释放
  * 次级配置器的内存池管理技术：每次配置一大块内存，维护对应的自由链表，共维护16个自由链表，分别管理8B-128B大小的内存块
    * 分配：根据所需要空间的大小（调整为8B的倍数）找到对应大小的链表，拔出一段空间
    * 回收：客户端释放空间，配置器回收回对应的链表
  * 优势：性能高效，避免内存碎片，不需要频繁从用户态切换内核态
  * 劣势：内存浪费；（8B的倍数，不连续）
# 4 push_back与emplace_back
* 传递来的参数直接在容器管理的内存空间中构造元素（调用了构造函数）
* push_back会创建一个局部临时对象，并将其压入容器
# 5 STL排序算法
* 快速排序、插入排序、堆排序
  * 数据量很大：快排
  * 数据比较有序：插入排序
  * 特殊恶劣情况：堆排序
# 6 排序复杂度
* 快排：选定一个基准值，比较元素与基准值，小的左边，大的右边
  * 时间：O(nlog n)，最坏O(n<sup>2</sup>)
* 堆排序：利用完全二叉树,升序用最大堆，降序用最小堆
  * 时间:O(nlog n)
* 冒泡:从前往后两两比较，逆序交换
  * 时间：O(n<sup>2</sup>),最好O(n)
* 插入；将后续元素插入前面的有序队列中
  * 时间：O(n<sup>2</sup>),最好O(n)
* 选择排序：每次选择最小值放在排好序的后面
  * 时间：O(n<sup>2</sup>)
* 归并排序：不断将序列划分为长度>=2的序列，排序后合并
  * 时间：O(nlog n)
* 希尔排序：改进的插入排序
  * 时间：O(n<sup>1.3-2</sup>)
* 桶排序：数组分到M个桶中
  * 时间：O(N+C),$C=N*(logN-logM)$,最好O(N)
# 7 哈希表
* 哈希表：根据关键码直接访问数据的数据结构；将关键码通过哈希函数映射到表中的位置访问元素
## 7.1 长度为什么是质数
* 降低发生冲突的概率，使哈希后的数据更加均匀
## 7.2 如何处理冲突
* 开放地址法：
  * 线性探测、平方探测
* 拉链法
## 7.3 如何删除元素
* 线性探测法不真正删除元素，只做个标记，删除会导致正常的查找出错