# c++基础
## 1 多态
### 1.1 什么是多态？c++如何实现？
多态：函数名或者接口具有多种状态
* 编译时多态：重载和模板
* 运行时多态：继承和虚函数
### 1.2 虚函数机制
* 虚函数表实现虚函数，虚函数表包含了一个类所有虚函数的地址
* 在包含虚函数的类对象中，内存空间头部有一个虚表指针管理虚表
* 子类对父类虚函数重写时，虚表虚函数地址改变
* 父类指针操作子类对象，指向实际调用的函数
* 虚函数在运行时调用
* 虚表存在类中，共享虚表
### 1.3 构造函数/析构函数中调用虚函数问题
* 构造函数不可，析构可且常用

### 1.4 c语言实现虚函数机制
* 手动构造父子关系
* 创建虚表
* 设置虚指针
* 填充虚表
* 虚函数重写情况要修改函数指针
## 2 内存模型、继承问题
### 2.1 c++类对象的内存布局
* 存在虚函数，虚指针放在内存空间头部
* 按照类继承顺序和字段声明顺序布局
* 多继承：有虚函数的父类都有虚表
* 钻石继承：父类、子类、公共基类（父类的父类），父类不再拷贝基类数据
### 2.2 钻石继承的问题，解决手段
* 二义性：两个父类拷贝的基类的数据和方法，子类不知道调用的是哪一个
* 虚继承解决：父类继承时加virtual（虚继承）
## 3 内存管理
### 3.1 c++内存管理
* 堆,采用molloc、free动态分配和释放空间，能分配较大的空间
* 栈，为函数的局部变量分配空间
* 全局/静态存储区，存储全局变量和静态变量
* 常量存储区，存放常量
* 自由存储区，具体实现可能是堆或者内存池，通过new、delete分配和释放内存
### 3.2 堆和栈的区别
* 堆：手动申请和释放内存，栈：由OS自动申请和释放
* 分配内存大小区别
* 堆会产生内存碎片，栈不会
* 分配效率，栈比堆高
* 堆地址从低向上，栈由高向下
### 3.3 c和c++分配内存
* c：molloc/free(库函数);c++:new/delete（操作符）
* new和delete可以调用构造函数，完成对象的空间分配和初始化，销毁和释放
* molloc/free 与 new/delete 不可混用
* molloc需要指定分配内存的大小，new不必
* new返回类型指针，安全；molloc返回void*，要强转
* new操作自由存储区，molloc操作堆
### 3.4 内存对齐（字节对齐），why？how？
* 内存对齐：c++结构体中的数据成员，它的内存地址是对齐字节大小的倍数
* why：提高cpu读取数据效率，节省内存
* how：结构体首地址被结构体中最宽的基本类型成员整除；每一额成员相对起始地址的偏移被该量整除；结构体总体大小能被最宽成员整除；编译器可以填充padding
* how：声明结构体：字节对齐的数据依次声明；小成员组合在一起；
## 4 类型转换
### 4.1 c++类型转换关键字
* const_cast:将const转非const，只能用于指针或引用
* static_cast：转换c++中内置基本数据类型转换
* dynamic_cast：基类与派生类的指针或者引用进行转换；运行时进行安全检查；使用它父类要有虚函数，否则编译不通过
* reinterpret_cast：可以转化任何内置的数据类型为其他任何的数据类型；指针与内置数据类型转化；比较不安全
### 4.2 static_cast和dynamic_cast的异同点
* 安全检查：前者编译时，后者运行时
### 4.3 dynamic_cast的原理
* 不知道
## 5 智能指针
### 5.1 c++智能指针
* 解决内存泄漏问题，自动释放内存。因为智能指针是一个类，函数结束时会调用析构函数
* shared_ptr、unique_ptr、weak_ptr
* shared_ptr：多个共享指针可以指向相同的对象，采取计数的机制，最后一个引用销毁，释放内存空间
* unique_ptr：同一时间段只有一个智能指针指向该对象
* weak_ptr：解决shared_ptr相互引用，死锁；不会增加对象的引用计数，可以与shared_ptr互相转换
### 5.2 shared_ptr实现机制
* 构造函数：将指针指向该对象，计数=1
* 拷贝构造函数：将指针指向该对象，计数++
* 赋值运算：=左边的shared_ptr计数-1，右边+1；左边为0，销毁shared_ptr指向的对象，释放空间
### 5.3 shared_ptr是否线程安全
* 引用计数本身是安全无锁的，但是它指向的对象的读写不是。所以他不是线程安全的
### 5.4 weak_ptr 与 raw ptr
* shared_ptr指向的对象被销毁，weak_ptr也会被释放；raw ptr会变成悬浮指针
## 6 关键字
### const
* 修饰常量，不可变
* 指针常量：指针是常量；常量指针：指针是常量
* 修饰函数，函数可以重载，函数不改变类成员数据，函数不可调用非const数据
### static
* 文件作用域：其他文件无法看见也无法使用
* 函数作用域：全局变量，只这个函数可见，只初始化一次
* 类的数据、函数：类共享的属性
### extern
* extern "c" void fun(int a,int b):告诉编译器按c的方式编译它
* 作为一个对函数或全局变量的外部声明，告诉编译器在其他模块寻找其定义
### explicit
* 类的构造函数是显式的，告诉编译器不能进行隐式转换
### constexpr
* 告诉编译器去验证（函数或者变量）是否是常数，以进行优化
## volatile
* 告诉编译器操作变量都从内存中取出，不使用寄存器中的备份
### mutable
* 类中const函数可以修改非静态成员
### auto与deltype
* 自动推导，编译器操心具体类型；auto不可推导函数形参和数组类型，deltype可以
## 7 左值右值、构造函数
### 7.1 什么是左值右值，为什么引入右值
* 左值：可寻址存储单元，=左边的值，离开作用域才销毁
* 右值：临时对象，=右边的值
* 右值引用必须绑定到右值得引用。通过&& 来获得右值引用
* why：支持移动操作，绑定一个要被销毁的对象，可以自由的移动其资源，避免拷贝，提高性能。std::move()将左值转为右值引用
### 7.2 why自定义拷贝构造，什么是深拷贝与浅拷贝
* why：特殊情况下，如类中中含有指针，两个指针指向同个对象，一个类对象析构后，指针delete掉，另一个变成悬浮指针
* 浅拷贝：直接复制指向某个对象的指针，新旧对象共享同一块内存
* 深拷贝：创建一个一模一样的新对象
### 7.3 移动构造函数与移动拷贝构造函数
* 前者传递的参数是一个右值引用，不分配新内存，接管传递来的对象的内存，移动后将源对象销；后者参数传递是一个左值引用，会造成重新分配内存，效率更低
## 8 内联函数与宏
### 8.1 内联函数的作用，缺点
* 编译器直接展开函数，避免函数调用的开销
* 缺点：代码膨胀，生成exe太大，cpu、内存资源占用；不方便调试；每次都需要重新编译头文件
### 8.2 宏
* 宏：在预处理阶段对命令进行替换
* define不会对参数类型进行检查，会有安全问题
## 9 c++新特性
### auto
### nullptr
* 代替NULL避免重载问题
### 智能指针
### 右值引用
### lambda
* 匿名的内联函数，没有垃圾回收，没有反射机制
## 10 指针和引用的区别
* 引用：别名；指针：有地址，占空间
* 指针可以指向别的对象，引用不可以
* 指针可以初始化nullptr，引用必须初始化一个已存在的对象
* 指针可以是多级指针，引用只一级
## 11 重载与重写以及隐藏的区别
* 重载：根据返回类型、参数列表决定调用哪一个函数
* 重写：派生类重写基类的虚函数，基类中的函数必须标为virtual
* 隐藏：派生类的同名函数把基类中的同名函数隐藏，即基类同名函数被屏蔽掉
## 12 Delete与Delete[]的区别
### delete[]如何确定delete次数？成员函数能否delete this
* 对于基本类型没区别；对于类以及自定义数据类型：delete[]调用所有元素的析构函数，释放所有内存
* new[]时，在分配数组空间多分配4个字节保存数组大小，delete[]就知道了
* 成员函数可以调用delete this；并且该对象还可以调用类的不包含类数据的虚函数的方法。代码放在代码段中不再类对象的内存空间中




